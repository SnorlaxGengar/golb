<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>snorlaxgengar</title>
    <link>https://snorlaxgengar.github.io/</link>
    <description>Recent content on snorlaxgengar</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 20 Apr 2021 10:49:24 +0800</lastBuildDate><atom:link href="https://snorlaxgengar.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Binary_search</title>
      <link>https://snorlaxgengar.github.io/post/binary_search/</link>
      <pubDate>Tue, 20 Apr 2021 10:49:24 +0800</pubDate>
      
      <guid>https://snorlaxgengar.github.io/post/binary_search/</guid>
      <description>二分搜索 总结   特殊情况(空数组处理)
  边界条件处理
  测试案例(空数组,超出左边界,超出右边界,奇偶数组)
  代码 #include &amp;#34;catch2/catch_all.hpp&amp;#34;#include &amp;lt;vector&amp;gt; using namespace std; int binarySearch(const vector&amp;lt;int&amp;gt; &amp;amp;v, int value) { // 空数组处理  if (v.empty()) { return -1; } int l {0}; // 使用auto自动推导为无符号整数,导致越界  // 最后一个元素索引为数组长度-1  int r = v.size() - 1; while (l &amp;lt;= r) { auto m = (l + r) / 2; // 使用v[m]比较而不是m  if (value &amp;lt; v[m]) { // 边界调整到相邻单位  r = m - 1; } else if (value &amp;gt; v[m]) { // 边界调整到相邻单位  l = m + 1; } else { return m; } } return -1; } TEST_CASE(&amp;#34;binary search&amp;#34;, &amp;#34;[binary search]&amp;#34;) { REQUIRE(binarySearch({}, 1) == -1); REQUIRE(binarySearch({1, 2, 3}, 1) == 0); REQUIRE(binarySearch({1, 2, 3}, 0) == -1); REQUIRE(binarySearch({1, 2, 3, 4}, 3) == 2); REQUIRE(binarySearch({1, 2, 3, 4}, 5) == -1); } </description>
    </item>
    
    <item>
      <title>Introduction</title>
      <link>https://snorlaxgengar.github.io/post/introduction/</link>
      <pubDate>Sat, 06 Feb 2021 13:26:48 +0800</pubDate>
      
      <guid>https://snorlaxgengar.github.io/post/introduction/</guid>
      <description>本来想在Gitee搭建博客, 居然要手机号码, 算了还是用Github.</description>
    </item>
    
    <item>
      <title>1432.可获得的最大点数</title>
      <link>https://snorlaxgengar.github.io/post/1432.maximum-points-you-can-obtain-from-cards/</link>
      <pubDate>Sat, 06 Feb 2021 11:43:09 +0800</pubDate>
      
      <guid>https://snorlaxgengar.github.io/post/1432.maximum-points-you-can-obtain-from-cards/</guid>
      <description>题目 几张卡牌 排成一行，每张卡牌都有一个对应的点数。点数由整数数组 cardPoints 给出。 每次行动，你可以从行的开头或者末尾拿一张卡牌，最终你必须正好拿 k 张卡牌。 你的点数就是你拿到手中的所有卡牌的点数之和。 给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-points-you-can-obtain-from-cards 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 2种思路   每次从两端取最大的数累加
  使用滑动窗口累加
  第1次尝试(解答错误) class Solution { public: int maxScore(const vector&amp;lt;int&amp;gt; &amp;amp;cardPoints, int k) { if (cardPoints.size() == 1) { return cardPoints[0]; } auto l = &amp;amp;cardPoints[0]; auto r = &amp;amp;cardPoints[cardPoints.size() - 1]; int result {0}; while (k &amp;gt; 0) { if (*l &amp;gt; *r) { result += *l; ++l; --k; } else if (*r &amp;gt; *l) { result += *r; --r; --k; } else { while (*l == *r) { result += *l; ++l; --r; --k; if (k &amp;lt;= 0) { break; } // 回滚  if (*l &amp;gt; *r) { result += *l; ++l; ++r; --k; } else if (*r &amp;gt; *l) { result += *r; --l; --r; --k; } if (k &amp;lt;= 0) { break; } } } } return result; } } 测试案例{11, 49, 100, 20, 86, 29, 72}, 4不通过.</description>
    </item>
    
  </channel>
</rss>
